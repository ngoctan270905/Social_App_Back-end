Tài liệu Luồng Xử Lý - Bình Luận (Comment Feature)

Tài liệu này mô tả chi tiết luồng dữ liệu của các API liên quan đến tính năng bình luận và trả lời bình luận trong hệ thống, bao gồm cả cơ chế thông báo thời gian thực.

1. Tạo Bình Luận Mới (Create New Comment)

Đây là luồng xử lý khi người dùng tạo một bình luận mới trên một bài viết.

1.  Client gửi yêu cầu tạo bình luận:
    Client gửi một HTTP POST request đến API endpoint /api/v1/comments/.
    Request này đính kèm Access Token trong Authorization header và body chứa post_id (ID của bài viết) và content (nội dung bình luận).

2.  API Server xử lý yêu cầu:
    API Server nhận request, xác thực Access Token và trích xuất user_id của người tạo bình luận.
    Server thực hiện các bước sau:
    *   Xác thực bài viết: Kiểm tra xem post_id có hợp lệ và bài viết có tồn tại hay không.
    *   Lưu bình luận: Tạo một document mới trong collection comments với post_id, user_id, content và các thông tin khác (ví dụ: created_at, updated_at).
    *   Cập nhật số lượng bình luận: Tăng trường comments_count trong document của bài viết tương ứng trong collection posts bằng $inc (atomic update).
        *   Lưu ý: Thao tác này (lưu bình luận và cập nhật count) được thực hiện tuần tự nhưng không chặn event loop.

3.  Kích hoạt thông báo thời gian thực (nếu cần):
    Ngay sau khi bình luận được tạo và lưu thành công, hệ thống sẽ kích hoạt một tiến trình nền (background task hoặc asyncio.create_task) để gửi thông báo.
    *   Hệ thống xác định chủ bài viết (post.user_id).
    *   Nếu user_id của người tạo bình luận khác với post.user_id, một thông báo loại "NEW_COMMENT" sẽ được gửi đến chủ bài viết qua WebSocket.

4.  API Server trả về kết quả:
    API Server trả về một response thành công (ví dụ: 201 Created) chứa thông tin chi tiết của bình luận vừa được tạo.

2. Trả Lời Bình Luận (Reply to Comment)

Luồng này mở rộng việc tạo bình luận, cho phép người dùng phản hồi một bình luận hiện có (nested comments).

1.  Client gửi yêu cầu trả lời bình luận:
    Client gửi một HTTP POST request đến API endpoint /api/v1/comments/.
    Request này đính kèm Access Token và body chứa post_id, content và parent_id (ID của bình luận cha mà người dùng đang trả lời).

2.  API Server xử lý yêu cầu:
    API Server nhận request, xác thực Access Token và trích xuất user_id.
    Server thực hiện các bước sau:
    *   Xác thực bài viết và bình luận cha: Kiểm tra post_id và parent_id có hợp lệ, đảm bảo bình luận cha tồn tại.
    *   Lưu bình luận trả lời: Tạo một document mới trong collection comments với post_id, user_id, content, parent_id và các thông tin khác.
    *   Cập nhật số lượng trả lời: Tăng trường reply_count của bình luận cha (parent_id) trong collection comments bằng $inc.
    *   Cập nhật tổng số bình luận bài viết: Tăng trường comments_count trong document của bài viết gốc trong collection posts bằng $inc.
        *   Lưu ý: Các thao tác cập nhật count (trên bài viết và bình luận cha) nên được thực hiện một cách hiệu quả, không chặn luồng chính (ví dụ: background tasks).

3.  Kích hoạt thông báo thời gian thực (nếu cần):
    Tương tự như tạo bình luận mới, một tiến trình nền sẽ được kích hoạt:
    *   Hệ thống xác định chủ bình luận cha (parent_comment.user_id).
    *   Nếu user_id của người trả lời khác với parent_comment.user_id, một thông báo loại "NEW_COMMENT" (hoặc "NEW_REPLY") sẽ được gửi đến chủ bình luận cha qua WebSocket.
    *   Kiểm tra thêm nếu người tạo bình luận trả lời cũng là chủ bài viết để tránh gửi thông báo trùng lặp hoặc không cần thiết.

4.  API Server trả về kết quả:
    API Server trả về một response thành công (ví dụ: 201 Created) chứa thông tin chi tiết của bình luận trả lời vừa được tạo.

3. Đọc Bình Luận và Trả Lời (Reading Comments & Replies)

Đây là luồng xử lý khi client muốn hiển thị danh sách bình luận hoặc các trả lời cho một bình luận cụ thể.

1.  Client gửi yêu cầu lấy bình luận gốc:
    Client gửi HTTP GET request đến API endpoint (ví dụ: /api/v1/posts/{post_id}/comments) để lấy danh sách các bình luận gốc của một bài viết.
    *   Lưu ý: API này thường hỗ trợ phân trang (page, limit) và sắp xếp theo thời gian (created_at).

2.  API Server xử lý yêu cầu:
    API Server truy vấn collection comments để tìm các document có post_id khớp và parent_id là null (bình luận gốc).
    *   Kết quả được sắp xếp và phân trang theo yêu cầu.
    *   Thông tin người dùng (user_id) và media (media - nếu có) liên quan đến bình luận sẽ được populate hoặc truy vấn riêng để trả về dữ liệu đầy đủ.

3.  Client gửi yêu cầu lấy các trả lời (Lazy Loading):
    Khi người dùng bấm vào "Xem thêm trả lời" hoặc tương tự trên một bình luận, Client gửi HTTP GET request đến API endpoint (ví dụ: /api/v1/comments/{comment_id}/replies).
    *   Lưu ý: API này cũng hỗ trợ phân trang.

4.  API Server xử lý yêu cầu:
    API Server truy vấn collection comments để tìm các document có parent_id khớp với comment_id được yêu cầu.
    *   Kết quả được sắp xếp và phân trang.
    *   Thông tin người dùng và media liên quan sẽ được populate hoặc truy vấn.

5.  API Server trả về kết quả:
    API Server trả về một response thành công (200 OK) chứa danh sách các bình luận hoặc trả lời tương ứng.

4. Thông Báo Thời Gian Thực (Real-time Notification)

Đây là cơ chế tổng quát để đẩy thông báo liên quan đến bình luận/trả lời đến người dùng ngay lập tức thông qua WebSocket.

1.  Client thiết lập kết nối WebSocket:
    Khi người dùng đăng nhập, Client thiết lập kết nối WebSocket đến ws://domain/api/v1/ws/notifications?token=....
    *   Access Token được sử dụng để xác thực và lấy user_id.
    *   Server lưu trữ kết nối WebSocket này trong một ConnectionManager (Map user_id tới List[WebSocket]) để hỗ trợ nhiều thiết bị.

2.  Hệ thống gửi thông báo:
    Khi có một sự kiện liên quan đến bình luận/trả lời mà cần thông báo cho một người dùng khác (ví dụ: người tạo bình luận hoặc chủ bài viết), NotificationService sẽ được gọi.
    *   NotificationService tạo một bản ghi thông báo vào MongoDB (để lưu lịch sử).
    *   NotificationService sử dụng ConnectionManager để tìm tất cả các kết nối WebSocket của user_id mục tiêu.
    *   Thông báo dưới dạng JSON payload (ví dụ: {"type": "NEW_COMMENT", "data": {...}}) được gửi đến tất cả các kết nối đó.
        *   Lưu ý: Việc gửi thông báo WebSocket là một non-blocking operation, thường được thực hiện trong một background task để không ảnh hưởng đến hiệu năng của API chính.

3.  Client nhận và hiển thị thông báo:
    Client nhận JSON payload qua kết nối WebSocket.
    Client xử lý payload và hiển thị thông báo tương ứng (ví dụ: hiển thị toast notification, cập nhật badge số lượng thông báo chưa đọc).

Tinh Thần Chung (Theo GEMINI.md)

*   Tránh Sequential I/O trong Loop: Đảm bảo các hoạt động đọc/ghi CSDL và gửi WebSocket không chặn luồng chính và được tối ưu hóa.
*   Không Blocking trong Async: Các tác vụ nặng (như cập nhật count, gửi noti) được xử lý trong background hoặc bằng cách không đồng bộ để không làm lag toàn bộ server.
*   Fan-out có kiểm soát: Gửi thông báo WebSocket tới nhiều thiết bị/người dùng được quản lý bởi ConnectionManager để tránh tự DDoS.
*   Idempotent: Các thao tác cập nhật count cần được xem xét để đảm bảo tính idempotent nếu có retry (ví dụ: sử dụng transactions hoặc $inc an toàn).